#!/usr/bin/env python3
# MIT License
# (c) 2025 Giampiero Grossi
"""
CliNO seasonal HLI mapping (0.25° global) with welfare categories.

Inputs:
  - --shapefile        : path to 'ne_110m_admin_0_countries.shp' (or similar) https://www.naturalearthdata.com/
  - --base_directory   : path to "Dataset/HLI_Projections_file_nc_2026-2050" #or 2051-2075 or 2076-2100
  - --file path        : f'projection_{variable_name}_data_{season}_2026_2050.nc') #or 2051-2075 or 2076-2100
Outputs:
  - <OUT>/2026_2050_all_ssps_welfare_HLI_projection_seasonal_maps.tiff/.eps/.png #or 2051-2075 or 2076-2100

Usage:
  python cliNO_map.py --baseline-dir /Dataset/HLI_Projections_file_nc_2026-2050 #or 2051-2075 or 2076-2100
                      --shape /path/ne_110m_admin_0_countries.shp
                      --out ./figures --dpi 600 --format tiff
"""

import netCDF4 as nc
import numpy as np
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import os
import geopandas as gpd
from shapely.geometry import mapping
from rasterio import features
from affine import Affine
from matplotlib.colors import ListedColormap, BoundaryNorm

# Function to extract data from NetCDF files
def extract_data_from_nc(file_path, variable_name):
    with nc.Dataset(file_path, 'r') as dataset:
        lats = dataset.variables['lat'][:]
        lons = dataset.variables['lon'][:]
        data = dataset.variables[variable_name][:]
    return lats, lons, data

# Function to create a raster mask of land areas
def create_land_mask(lats, lons):
    shapefile_path = "Your path.../ne_110m_admin_0_countries/ne_110m_admin_0_countries.shp"
    world = gpd.read_file(shapefile_path)
    land_geom = [mapping(world.geometry.union_all())]
    x_res = (lons[-1] - lons[0]) / (len(lons) - 1)
    y_res = (lats[-1] - lats[0]) / (len(lats) - 1)
    transform = Affine.translation(
        lons[0] - x_res / 2, lats[0] - y_res / 2
    ) * Affine.scale(x_res, y_res)
    mask = features.rasterize(
        shapes=land_geom,
        out_shape=(len(lats), len(lons)),
        transform=transform,
        fill=0,
        default_value=1,
        dtype=np.uint8
    )
    return mask

# Function to apply the land area mask to the data
def apply_land_mask(data, land_mask):
    return np.where(land_mask == 1, data, np.nan)

# Function to create a subplot for each season
def create_seasonal_subplot(ax, lats, lons, data, title, vmin, vmax):
    ax.set_title(title, fontsize=16, fontfamily='serif')
    ax.coastlines(linewidth=0.4)
    gl = ax.gridlines(draw_labels=True, linewidth=0.5, color='gray', alpha=0.5, linestyle='--')
    gl.top_labels = False
    gl.right_labels = False
    gl.xlabel_style = {'size': 10, 'color': 'black', 'fontfamily': 'Times New Roman'}
    gl.ylabel_style = {'size': 10, 'color': 'black', 'fontfamily': 'Times New Roman'}
    ax.set_extent([-180, 180, -60, 90], crs=ccrs.PlateCarree())
    im = ax.pcolormesh(
        lons, lats, data,
        cmap=cmap,
        norm=norm,
        shading='auto',
        transform=ccrs.PlateCarree()
    )
    return im

# Main function to create the figure with all seasonal maps for each SSP
def main():
    base_directory = "Your path...Dataset/HLI_Projections_file_nc_2026-2050" #or 2051-2075 or 2076-2100
    ssp_dirs = ['SSP1-2.6', 'SSP2-4.5', 'SSP3-7.0', 'SSP5-8.5']
    seasons = ['DJF', 'MAM', 'JJA', 'SON']
    variable_name = 'HLI'

    # Extract data for each SSP and season
    data_dict = {}
    for ssp in ssp_dirs:
        data_dict[ssp] = {}
        for season in seasons:
            file_path = os.path.join(base_directory, ssp, f'projection_{variable_name}_data_{season}_2026_2050.nc') #or 2051-2075 or 2076-2100
            lats, lons, data = extract_data_from_nc(file_path, variable_name)
            data_dict[ssp][season] = data

    # Create the land mask
    land_mask = create_land_mask(lats, lons)

    # Apply land mask to all data
    for ssp in ssp_dirs:
        for season in seasons:
            data_dict[ssp][season] = apply_land_mask(data_dict[ssp][season], land_mask)

    # Definisci le nuove categorie di THI e i colori corrispondenti
    max_value = np.nanmax([
    np.nanmax(data_dict[ssp][season])
    for ssp in ssp_dirs
    for season in seasons])
    categories = [0, 70, 77, 86, 96, max_value + 1]
    colors = ['#4CAF50', '#FFEB3B', '#FF9800', '#B71C1C', '#380000']
    
    # Crea una mappa di colori personalizzata
    global cmap, norm
    cmap = ListedColormap(colors)
    norm = BoundaryNorm(categories, cmap.N)

    # Create the figure and axes for the seasonal maps of all SSPs
    fig, axes = plt.subplots(nrows=4, ncols=4, figsize=(20, 16), subplot_kw={'projection': ccrs.PlateCarree()})
    #fig.suptitle('Livestock welfare categories for CliNO period', fontsize=24, fontfamily='Times New Roman', x=0.55, y=0.77)

    # Spacing parameters for customization
    vertical_space = 0.15
    ssp_label_distance = -0.15
    colorbar_distance = 0.09
    colorbar_shift_right = 0.04

    # Create subplots for each SSP and season
    for row, ssp in enumerate(ssp_dirs):
        for col, season in enumerate(seasons):
            ax = axes[row, col]
            im = create_seasonal_subplot(ax, lats, lons, data_dict[ssp][season], title=season, vmin=categories[0], vmax=categories[-2])
            if col == 0:
                ax.text(ssp_label_distance, 0.5, ssp, va='center', ha='right', fontsize=16, fontweight='bold', rotation='vertical', transform=ax.transAxes, fontfamily='serif')

    # Add a single color bar for all subplots
    cbar_ax = fig.add_axes([0.20 + colorbar_shift_right, colorbar_distance, 0.6, 0.02])
    cbar = fig.colorbar(im, cax=cbar_ax, orientation='horizontal', ticks=[(categories[i] + categories[i+1]) / 2 for i in range(len(categories)-1)])
    cbar.set_label('HLI welfare categories', fontsize=16, fontfamily='Times New Roman')
    cbar.ax.tick_params(labelsize=14)
    cbar.set_ticklabels([
    'HLI ≤ 70',
    '70 < HLI ≤ 77',
    '77 < HLI ≤ 86',
    '86 < HLI ≤ 96',
    'HLI > 96'
])

    plt.tight_layout(rect=[0.05, 0.1, 1, 0.95 - vertical_space])
    plt.savefig(f'{variable_name}_all_ssps_welfare_HLI_projection_seasonal_maps.tiff', dpi=600, bbox_inches='tight')
    plt.show()

if __name__ == "__main__":
    main()
